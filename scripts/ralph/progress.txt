# Ralph Progress Log

Started: 2026-01-21T00:00:00Z
Branch: main

## Overview

This log tracks Ralph's learning and progress as it works through the product requirements in prd.json.
Each iteration documents what worked well, challenges encountered, patterns discovered, and gotchas to avoid.

---

## Project Context

**Mindweave** - AI-Powered Personal Knowledge Hub
- Framework: Next.js 15 (App Router), TypeScript 5.5
- Database: PostgreSQL 16 + pgvector
- ORM: Drizzle ORM
- Auth: Auth.js v5 (JWT sessions)
- AI: Claude API (Anthropic) + Google Gemini (embeddings)
- Testing: Vitest + React Testing Library + Playwright
- Styling: Tailwind CSS + shadcn/ui

**Completed Features:**
1. ✅ Authentication Flow (Google OAuth + JWT sessions) - 97 tests, 94.73% coverage
2. ✅ Note Capture (Form + validation + database) - 124 tests, 81.03% coverage
3. ✅ Content Library (Filtering + sorting + components) - 164 tests, 87.5% coverage

**Next Features (from prd.json):**
4. Full-text Search
5. Manual Tagging
6. Claude Auto-Tagging
7. Vector Embeddings
8. Semantic Search
9. Knowledge Q&A Chat

---

## Patterns & Conventions (from previous features)

### ✅ What Works Well

1. **Feature Branch Workflow**
   - Create feature branch: `git checkout -b feature/feature-name`
   - Implement with TDD: tests first, then implementation
   - Run all checks in feature branch before merge
   - Merge to main with `--no-ff` for clear history
   - Run ALL tests in main after merge to catch regressions

2. **Test-Driven Development**
   - Write tests BEFORE implementation
   - Aim for ≥80% coverage minimum
   - Unit tests for business logic
   - Component tests for React components (React Testing Library)
   - Integration tests for API routes and database operations
   - E2E tests for critical user flows (Playwright)

3. **Server Actions Pattern**
   - Create server actions in `app/actions/` directory
   - Authenticate with `await auth()` at the top
   - Return `{ success: boolean, ... }` result objects
   - Use Zod schemas for validation
   - Perform database operations with Drizzle ORM

4. **Component Structure**
   - Server components by default
   - Client components only when needed (`'use client'`)
   - Extract reusable components (ContentCard, FilterBar pattern)
   - Use shadcn/ui for base components
   - Tailwind CSS for styling

5. **Database-Level Operations**
   - Filter and sort at database level (not in-memory)
   - Use Drizzle ORM query builders (`eq()`, `or()`, `sql`)
   - For array containment: `sql\`${column} @> ARRAY[${value}]::text[]\``
   - Index key columns for performance

### ⚠️ Gotchas to Avoid

1. **Edge Runtime Limitations**
   - JWT sessions required for middleware (database sessions don't work in Edge Runtime)
   - Use integer Unix timestamps for expires columns (not timestamp type)
   - Some libraries don't work in Edge Runtime - check compatibility

2. **Type Safety**
   - Use strict TypeScript mode
   - Avoid `any` unless absolutely necessary
   - Add `@ts-expect-error` with clear explanation when needed (like auth adapter type mismatches)
   - Use Zod for runtime validation

3. **Testing**
   - Mock external APIs (Claude, Gemini) in tests
   - Use test database helpers for setup/teardown
   - Mock `useSearchParams` and `useRouter` in Next.js component tests
   - Clean up database state between tests

4. **Route Paths**
   - Protected routes under `/dashboard` directory
   - Use `/dashboard/` prefix in all navigation links
   - Middleware protects entire `/dashboard/*` path

5. **Documentation**
   - Update STATUS.md after every feature completion
   - Update README.md feature checklist
   - Commit documentation updates separately
   - Keep AGENTS.md updated with AI integration changes

---

## Iteration History

(Ralph will append entries here after each iteration)

<!-- Example format:
## Iteration 1 - 2026-01-21T12:00:00Z
Story: feature-4 (Full-text Search)
Status: In Progress
Coverage: 75%

### What Worked
- Successfully implemented search bar component
- PostgreSQL full-text search performing well

### Challenges
- URL parameter handling needed refactoring
- Test coverage initially below 80%

### Learnings
- Use ts_rank for relevance scoring
- Combine tsvector columns for multi-field search

### Next Steps
- Add highlighting to search results
- Increase test coverage to ≥80%
-->

## Iteration 1 - 2026-01-22T02:41:40+00:00
Status: 6 incomplete stories remaining

## Iteration 2 - 2026-01-22T02:41:42+00:00
Status: 6 incomplete stories remaining

## Iteration 3 - 2026-01-22T02:41:45+00:00
Status: 6 incomplete stories remaining

## Iteration 4 - 2026-01-22T02:41:48+00:00
Status: 6 incomplete stories remaining

## Iteration 5 - 2026-01-22T02:41:50+00:00
Status: 6 incomplete stories remaining

## Iteration 6 - 2026-01-22T02:41:53+00:00
Status: 6 incomplete stories remaining

## Iteration 7 - 2026-01-22T02:41:55+00:00
Status: 6 incomplete stories remaining

## Iteration 8 - 2026-01-22T02:41:58+00:00
Status: 6 incomplete stories remaining

## Iteration 9 - 2026-01-22T02:42:00+00:00
Status: 6 incomplete stories remaining

## Iteration 10 - 2026-01-22T02:42:03+00:00
Status: 6 incomplete stories remaining

## Iteration 11 (Manual) - 2026-01-22T03:24:00Z
Story: feature-4 (Full-text Search)
Status: Complete ✅
Coverage: 89.71%

### What Worked
- PostgreSQL ILIKE for case-insensitive search (simpler than full-text search)
- UNNEST for searching within array fields (tags, autoTags)
- SearchBar component with 300ms debounce for better UX
- Combining search with existing filters (type, tag, sorting)
- Created Input UI component following shadcn/ui pattern
- URL parameter persistence using Next.js searchParams
- Comprehensive E2E tests (22 test scenarios)

### Challenges
- Initial TypeScript errors with Input component (empty interface)
- E2E test helper function signature mismatch (createTestContent)
- Fixed with Python script to update all test calls correctly
- Button aria-label needed for accessibility

### Learnings
- Use PostgreSQL ILIKE instead of full-text search for simple queries
- UNNEST in SQL to search within PostgreSQL arrays
- Debouncing search input improves performance (300ms is good balance)
- Always add aria-label to icon-only buttons for accessibility
- Python scripts useful for bulk find-and-replace in test files
- createTestContent(userId, data) signature from existing helpers

### Patterns Confirmed
- Server actions in app/actions/ for mutations
- Database-level filtering (not in-memory)
- URL parameters for client-side state persistence
- Component tests with mocked Next.js hooks (useRouter, useSearchParams)
- E2E tests for complete user flows

### Gotchas to Avoid
- Remember to add aria-label to buttons with only icons
- Check test helper function signatures before writing tests
- Use type alias instead of empty interface (ESLint rule)
- ILIKE is simpler than to_tsquery for basic search needs

### Technical Notes
- Search implementation uses ILIKE with wildcards (%query%)
- Searches across: title, body, tags array, autoTags array
- Works with filters: type (note/link/file), tag, sortBy, sortOrder
- 182 total tests passing (including 18 new SearchBar tests)
- 22 E2E test scenarios covering all search combinations

## Iteration 12 (Manual) - 2026-01-22T05:11:00Z
Story: feature-5 (Manual Tagging)
Status: Complete ✅
Coverage: 92.22%

### What Worked
- Badge component with removable functionality (100% coverage)
- TagInput component with autocomplete from existing tags (95.91% coverage)
- EditableTags component for inline editing (94.11% coverage)
- updateContentTagsAction server action with validation
- Auto-save with 1 second debounce for better UX
- Tag suggestions filtered to exclude already selected tags
- Optimistic UI updates with comprehensive error handling
- Integration with ContentCard component seamless
- Comprehensive E2E tests (60+ test scenarios)

### Challenges
- Initial test failures due to fake timers in auto-save tests
- React Testing Library "act" warnings in async tests
- Needed to mock TagInput component in EditableTags tests for simplicity
- Fixed by using waitFor with proper timeout instead of fake timers

### Learnings
- Avoid fake timers (vi.useFakeTimers) with userEvent in tests - causes timeouts
- Use waitFor with realistic timeout for auto-save testing (1100ms)
- Mock child components to simplify parent component tests
- Remove unused imports immediately to avoid linting warnings
- Test debounced auto-save with real timers, not fake timers
- Use data-testid for mocked components to simplify assertions

### Patterns Confirmed
- Server actions pattern: auth check → validation → database operation → revalidatePath
- Component composition: Badge → TagInput → EditableTags
- Controlled component pattern with onChange callbacks
- shadcn/ui styling patterns with cn() utility
- Ref forwarding for all base UI components

### Gotchas to Avoid
- Don't use vi.useFakeTimers with userEvent.setup() - causes test timeouts
- Always clear mocks with vi.clearAllMocks() in beforeEach
- Mock server actions in component tests to avoid Next.js errors
- Use catch-all catch {} instead of catch(err) if error variable unused
- Test auto-save with real setTimeout, not fake timers

### Technical Notes
- Tag validation: max 20 tags, max 50 chars each, trimmed, no duplicates
- Auto-save triggers 1 second after last tag change
- Autocomplete shows top 5 suggestions filtered by input
- Tags stored as PostgreSQL text[] array
- Remove tag with backspace when input is empty
- ESC key closes autocomplete suggestions
- Enter key adds tag or selects first suggestion
- Click outside closes suggestions (useEffect with event listener)
- 241 total tests passing (59 new tag-related unit tests + 60+ E2E)
- Component tests use mocked dependencies for isolation

### Components Created
1. Badge (badge.tsx) - 15 tests, 100% coverage
2. TagInput (tag-input.tsx) - 26 tests, 95.91% coverage  
3. EditableTags (EditableTags.tsx) - 18 tests, 94.11% coverage
4. Server Action: updateContentTagsAction - tested via E2E

### Files Modified
- app/actions/content.ts - added updateContentTagsAction
- app/dashboard/library/page.tsx - pass allTags to ContentCard
- components/library/ContentCard.tsx - use EditableTags component
- app/actions/content.test.ts - documented E2E test coverage

